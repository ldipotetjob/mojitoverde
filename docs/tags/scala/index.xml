<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>scala on Green Mojito in technology</title>
    <link>https://ldipotetjob.github.io/mojitoverde/tags/scala/</link>
    <description>Recent content in scala on Green Mojito in technology</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Scadip</copyright>
    <lastBuildDate>Mon, 06 Apr 2020 09:00:00 +0000</lastBuildDate><atom:link href="https://ldipotetjob.github.io/mojitoverde/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>With Futures in Scala who brings the core, Java Concurrency api?</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2020-04-06-futureinscala/</link>
      <pubDate>Mon, 06 Apr 2020 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2020-04-06-futureinscala/</guid>
      <description>I will not talk about the syntax of Scala&amp;rsquo;s Future. You can find everything at Scala Official documentation.
It is clear what Scala Futures is for. I think that it is the best solution for concurrency and any other asynchronous processing.
My challenge today will be to try to explain the core of Scala Futures and who provides it. I will attempt to give you an idea in relation to the link between the Scala Concurrency package and the Java Concurrency package.</description>
    </item>
    
    <item>
      <title>Akka an intelligent solution for concurrency</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2019-03-10-akkaconcurrencysolution/</link>
      <pubDate>Sun, 10 Mar 2019 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2019-03-10-akkaconcurrencysolution/</guid>
      <description>We have a concurrency problem: I need to process and parse hundreds of thousands of websites asynchronously. I tried many options with something in mind always: Futures. By coding in that manner, I produce something akin to the following:
1//.................... 2 3//game_1: Int value indicating first game 4 5//game_n: Int value indicating game n 6 7val resultMatch:List[Future[List[Match]]] = (game_1 until game_n).map { 8 matchnum =&amp;gt; 9 Future{ 10 new ParserFootbalHTML(&amp;#34;https://www.anyurl.com/...&amp;#34; + matchnum).</description>
    </item>
    
    <item>
      <title>Generating scala application distribution in akka &amp; play for different environments</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2019-02-12-generatedistroplayscala/</link>
      <pubDate>Tue, 12 Feb 2019 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2019-02-12-generatedistroplayscala/</guid>
      <description>From my perspective, Sbt is quite complex. I need to work with the sbt documentation at hand. Many people think that SBT is confusing, complicated, and opaque. My goal today: **how to generate distribution packages for different environments ** just in one command line clean + compile + build distribution + specific environment.
What do we need:  Pass parameters to our process indicating what environment you want to build. Create a plugin to read the parameters.</description>
    </item>
    
    <item>
      <title>Scheduling in Akka with Quartz - a wise solution</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2018-09-24-scalaakkaquartz/</link>
      <pubDate>Mon, 24 Sep 2018 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2018-09-24-scalaakkaquartz/</guid>
      <description>The problem I bring: how to execute several tasks following a specific schedule (day/time) for the long term and different patterns? The previous schedule must be able to vary in time.
Our scenario:
 A process like Linux cron services for running commands following a predetermined schedule. Objects that process configuration files that contain a list of command lines. The config file, which you can configure dynamically, contains the schedule of command invocation.</description>
    </item>
    
    <item>
      <title>Scala - Abstract  - Generic Type</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2018-06-13-scalageneric/</link>
      <pubDate>Wed, 13 Jun 2018 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2018-06-13-scalageneric/</guid>
      <description>In this post, we talk about Generic Elements, one of the most useful mechanisms in the Scala programming language. The use of Generic Elements is quite helpful when a member of a class, feature, or method definition does not have a complete implementation in its body and can also be usable by different implementations.
The following example is simple and will show how to use inheritance and polymorphism:
1trait AddOper { 2 type T 3 def processElemnt(x: T, y: T): T 4} 5 6class ConcatString extends AddOper{ 7 type T = String 8 override def processElemnt (x: String, y: String): String = 9 x + y 10} 11 12class ConcatInt extends AddOper{ 13 type T = Int 14 override def processElemnt (x: Int, y: Int): Int = 15 x + y 16} In the same way, parameterization allows the writing of generic classes and traits.</description>
    </item>
    
    <item>
      <title>Api Rest - Playframework - Testing</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2018-05-30-scalatestingplay/</link>
      <pubDate>Wed, 30 May 2018 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2018-05-30-scalatestingplay/</guid>
      <description>As was argued by Robert C. Martin in his Clean Code bible, there are several aspects that we have to pay attention when we design our tests:
 Minimize the number of assert per concept. Test just one concept per test function. Test should not depend on each other. Test should run in any environment.  Test should pass or fail BUT you should not make process or any other thing for check if the Test was OK or failed.</description>
    </item>
    
    <item>
      <title>Scala - Trait - inheritance</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-28-scalatraitinheritance/</link>
      <pubDate>Fri, 28 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-28-scalatraitinheritance/</guid>
      <description>We&amp;rsquo;ll talk today about the Scala traits and how to implement inheritance with classes. In some scenarios like having to deal with a base class with arguments on its constructor, it&amp;rsquo;s better to use abstract classes instead of traits. Classes and objects can extend from traits that encapsulate methods and field definitions.
We show here a quite simple example (base class with arguments) inherits(implements too) from abstract class:
1abstract class Element { 2 def contents: Array[String] 3 def height = contents.</description>
    </item>
    
    <item>
      <title>Scala - Classes - Objects</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-12-scalaclassobject/</link>
      <pubDate>Wed, 12 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-12-scalaclassobject/</guid>
      <description>In this post, we talk about Scala Classes and Objects. Its relationships between different components and inheritance. We assume that classes, methods, and polymorphism are familiar to the reader. We only will delve into new terms in this scenario.
The example below(or its idea) is from Programming in scala, 3rd edition
When defining classes in Scala is like a blueprint for creating objects.
Let&amp;rsquo;s define a simple implementation of the Rational numbers(simple operations):</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Data Types - Operators</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-04-scaladataoperator/</link>
      <pubDate>Tue, 04 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-04-scaladataoperator/</guid>
      <description>In this post, we talk about Scala Data Types and their perspective in the easiest way.
Basic type Range Byte 8-bit signed two&#39;s complement integer (-27 to 27 - 1, inclusive) Short 16-bit signed two&#39;s complement integer (-215 to 215 - 1, inclusive) Int 32-bit signed two&#39;s complement integer (-231 to 231 - 1, inclusive) Long 64-bit signed two&#39;s complement integer (-263 to 263 - 1, inclusive) Char 16-bit unsigned Unicode character (0 to 216 - 1, inclusive) String a sequence of Chars Float 32-bit IEEE 754 single-precision float Double 64-bit IEEE 754 double-precision float Boolean true or false Scala brings a mechanism for string interpolation, which allows embedding expressions within string literals:</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Functions</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-28-scalafunc/</link>
      <pubDate>Tue, 28 Mar 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-28-scalafunc/</guid>
      <description>In this post, I will talk about the role of functions in scala, how to create them, and their implication on the scala language. Scala REPL (“Read-Evaluate-Print-Loop”),scala 2.x, will help us.
Scala REPL page:
use :quit to exit from the scala REPL. use tab for completion. use :help for a list of commands. use :paste to enter a class and object as companions. The telltale sign of a function with side effects is that its result type is Unit.</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Collections - List</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-21-scalanutshell/</link>
      <pubDate>Tue, 21 Mar 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-21-scalanutshell/</guid>
      <description>In this post I&amp;rsquo;m going to explain one of the main collections in Scala, List. The performance in this inmutable collection for some scenarios is great with optimal features however, it doesn&amp;rsquo;t work as well in others scenarios because this performance is proportional to the size of the collection.
You can find the performance of List and other collections here.
Specific for List, this is what we have:
   head tail apply update prepend append insert     C C L L C L -    C	The operation takes (fast) constant time.</description>
    </item>
    
  </channel>
</rss>
