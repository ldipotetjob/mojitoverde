<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scala on Green Mojito in technology</title>
    <link>https://ldipotetjob.github.io/mojitoverde/tags/scala/</link>
    <description>Recent content in Scala on Green Mojito in technology</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Scadip</copyright>
    <lastBuildDate>Wed, 13 Jun 2018 09:00:00 +0000</lastBuildDate><atom:link href="https://ldipotetjob.github.io/mojitoverde/tags/scala/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Scala - Abstract  - Generic Type</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2018-06-13-scalageneric/</link>
      <pubDate>Wed, 13 Jun 2018 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2018-06-13-scalageneric/</guid>
      <description>In this post, we talk about Generic Elements, one of the most useful mechanisms in the Scala programming language. The use of Generic Elements is quite helpful when a member of a class, feature, or method definition does not have a complete implementation in its body and can also be usable by different implementations.
The following example is simple and will show how to use inheritance and polymorphism:
1trait AddOper { 2 type T 3 def processElemnt(x: T, y: T): T 4} 5 6class ConcatString extends AddOper{ 7 type T = String 8 override def processElemnt (x: String, y: String): String = 9 x + y 10} 11 12class ConcatInt extends AddOper{ 13 type T = Int 14 override def processElemnt (x: Int, y: Int): Int = 15 x + y 16} In the same way, parameterization allows the writing of generic classes and traits.</description>
    </item>
    
    <item>
      <title>Api Rest - Playframework - Testing</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2018-05-30-scalatestingplay/</link>
      <pubDate>Wed, 30 May 2018 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2018-05-30-scalatestingplay/</guid>
      <description>As was argued by Robert C. Martin in his Clean Code bible, there are several aspects that we have to pay attention when we design our tests:
 Minimize the number of assert per concept. Test just one concept per test function. Test should not depend on each other. Test should run in any environment.  Test should pass or fail BUT you should not make process or any other thing for check if the Test was OK or failed.</description>
    </item>
    
    <item>
      <title>Scala - Trait - inheritance</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-28-scalatraitinheritance/</link>
      <pubDate>Fri, 28 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-28-scalatraitinheritance/</guid>
      <description>We&amp;rsquo;ll talk today about the Scala traits and how to implement inheritance with classes. In some scenarios like having to deal with a base class with arguments on its constructor, it&amp;rsquo;s better to use abstract classes instead of traits. Classes and objects can extend from traits that encapsulate methods and field definitions.
We show here a quite simple example (base class with arguments) inherits(implements too) from abstract class:
1abstract class Element { 2 def contents: Array[String] 3 def height = contents.</description>
    </item>
    
    <item>
      <title>Scala - Classes - Objects</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-12-scalaclassobject/</link>
      <pubDate>Wed, 12 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-12-scalaclassobject/</guid>
      <description>In this post, we talk about Scala Classes and Objects. Its relationships between different components and inheritance. We assume that classes, methods, and polymorphism are familiar to the reader. We only will delve into new terms in this scenario.
The example below(or its idea) is from Programming in scala, 3rd edition
When defining classes in Scala is like a blueprint for creating objects.
Let&amp;rsquo;s define a simple implementation of the Rational numbers(simple operations):</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Data Types - Operators</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-04-scaladataoperator/</link>
      <pubDate>Tue, 04 Apr 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-04-04-scaladataoperator/</guid>
      <description>In this post, we talk about Scala Data Types and their perspective in the easiest way.
Basic type Range Byte 8-bit signed two&#39;s complement integer (-27 to 27 - 1, inclusive) Short 16-bit signed two&#39;s complement integer (-215 to 215 - 1, inclusive) Int 32-bit signed two&#39;s complement integer (-231 to 231 - 1, inclusive) Long 64-bit signed two&#39;s complement integer (-263 to 263 - 1, inclusive) Char 16-bit unsigned Unicode character (0 to 216 - 1, inclusive) String a sequence of Chars Float 32-bit IEEE 754 single-precision float Double 64-bit IEEE 754 double-precision float Boolean true or false Scala brings a mechanism for string interpolation, which allows embedding expressions within string literals:</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Functions</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-28-scalafunc/</link>
      <pubDate>Tue, 28 Mar 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-28-scalafunc/</guid>
      <description>In this post, I will talk about the role of functions in scala, how to create them, and their implication on the scala language. Scala REPL (“Read-Evaluate-Print-Loop”),scala 2.x, will help us.
Scala REPL page:
use :quit to exit from the scala REPL. use tab for completion. use :help for a list of commands. use :paste to enter a class and object as companions. The telltale sign of a function with side effects is that its result type is Unit.</description>
    </item>
    
    <item>
      <title>Scala in a nutshell - Collections - List</title>
      <link>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-21-scalanutshell/</link>
      <pubDate>Tue, 21 Mar 2017 09:00:00 +0000</pubDate>
      
      <guid>https://ldipotetjob.github.io/mojitoverde/posts/2017-03-21-scalanutshell/</guid>
      <description>In this post I&amp;rsquo;m going to explain one of the main collections in Scala, List. The performance in this inmutable collection for some scenarios is great with optimal features however, it doesn&amp;rsquo;t work as well in others scenarios because this performance is proportional to the size of the collection.
You can find the performance of List and other collections here.
Specific for List, this is what we have:
   head tail apply update prepend append insert     C C L L C L -    C	The operation takes (fast) constant time.</description>
    </item>
    
  </channel>
</rss>
